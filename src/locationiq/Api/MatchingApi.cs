/* 
 * LocationIQ
 *
 * LocationIQ provides flexible enterprise-grade location based solutions. We work with developers, startups and enterprises worldwide serving billions of requests everyday. This page provides an overview of the technical aspects of our API and will help you get started.
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using locationiq.Client;
using locationiq.Model;

namespace locationiq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMatchingApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Matching Service
        /// </summary>
        /// <remarks>
        /// Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>DirectionsMatching</returns>
        DirectionsMatching Matching (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string));

        /// <summary>
        /// Matching Service
        /// </summary>
        /// <remarks>
        /// Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>ApiResponse of DirectionsMatching</returns>
        ApiResponse<DirectionsMatching> MatchingWithHttpInfo (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Matching Service
        /// </summary>
        /// <remarks>
        /// Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>Task of DirectionsMatching</returns>
        System.Threading.Tasks.Task<DirectionsMatching> MatchingAsync (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string));

        /// <summary>
        /// Matching Service
        /// </summary>
        /// <remarks>
        /// Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>Task of ApiResponse (DirectionsMatching)</returns>
        System.Threading.Tasks.Task<ApiResponse<DirectionsMatching>> MatchingAsyncWithHttpInfo (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MatchingApi : IMatchingApi
    {
        private locationiq.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MatchingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MatchingApi(String basePath)
        {
            this.Configuration = new locationiq.Client.Configuration { BasePath = basePath };

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MatchingApi"/> class
        /// </summary>
        /// <returns></returns>
        public MatchingApi()
        {
            this.Configuration = locationiq.Client.Configuration.Default;

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MatchingApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public MatchingApi(locationiq.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = locationiq.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public locationiq.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public locationiq.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Matching Service Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>DirectionsMatching</returns>
        public DirectionsMatching Matching (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string))
        {
             ApiResponse<DirectionsMatching> localVarResponse = MatchingWithHttpInfo(coordinates, generateHints, approaches, exclude, bearings, radiuses, steps, annotations, geometries, overview, timestamps, gaps, tidy, waypoints);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Matching Service Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>ApiResponse of DirectionsMatching</returns>
        public ApiResponse<DirectionsMatching> MatchingWithHttpInfo (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string))
        {
            // verify the required parameter 'coordinates' is set
            if (coordinates == null)
                throw new ApiException(400, "Missing required parameter 'coordinates' when calling MatchingApi->Matching");

            var localVarPath = "/matching/driving/{coordinates}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (coordinates != null) localVarPathParams.Add("coordinates", this.Configuration.ApiClient.ParameterToString(coordinates)); // path parameter
            if (generateHints != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "generate_hints", generateHints)); // query parameter
            if (approaches != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "approaches", approaches)); // query parameter
            if (exclude != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "exclude", exclude)); // query parameter
            if (bearings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "bearings", bearings)); // query parameter
            if (radiuses != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "radiuses", radiuses)); // query parameter
            if (steps != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "steps", steps)); // query parameter
            if (annotations != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "annotations", annotations)); // query parameter
            if (geometries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "geometries", geometries)); // query parameter
            if (overview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "overview", overview)); // query parameter
            if (timestamps != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timestamps", timestamps)); // query parameter
            if (gaps != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gaps", gaps)); // query parameter
            if (tidy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tidy", tidy)); // query parameter
            if (waypoints != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "waypoints", waypoints)); // query parameter

            // authentication (key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", this.Configuration.GetApiKeyWithPrefix("key")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Matching", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DirectionsMatching>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DirectionsMatching) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DirectionsMatching)));
        }

        /// <summary>
        /// Matching Service Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>Task of DirectionsMatching</returns>
        public async System.Threading.Tasks.Task<DirectionsMatching> MatchingAsync (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string))
        {
             ApiResponse<DirectionsMatching> localVarResponse = await MatchingAsyncWithHttpInfo(coordinates, generateHints, approaches, exclude, bearings, radiuses, steps, annotations, geometries, overview, timestamps, gaps, tidy, waypoints);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Matching Service Matching API matches or snaps given GPS points to the road network in the most plausible way.  Please note the request might result multiple sub-traces.  Large jumps in the timestamps (&gt; 60s) or improbable transitions lead to trace splits if a complete matching could not be found. The algorithm might not be able to match all points. Outliers are removed if they can not be matched successfully.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="coordinates">String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6}). polyline follows Google&#39;s polyline format with precision 5</param>
        /// <param name="generateHints">Adds a Hint to the response which can be used in subsequent requests, see hints parameter. Input Value - true (default), false Format - Base64 String (optional)</param>
        /// <param name="approaches">Keep waypoints on curb side. Input Value - {approach};{approach}[;{approach} ...] Format - curb or unrestricted (default) (optional)</param>
        /// <param name="exclude">Additive list of classes to avoid, order does not matter. input Value - {class}[,{class}] Format - A class name determined by the profile or none. (optional)</param>
        /// <param name="bearings">Limits the search to segments with given bearing in degrees towards true north in clockwise direction. List of positive integer pairs separated by semi-colon and bearings array should be equal to length of coordinate array. Input Value :- {bearing};{bearing}[;{bearing} ...] Bearing follows the following format : bearing {value},{range} integer 0 .. 360,integer 0 .. 180 (optional)</param>
        /// <param name="radiuses">Limits the search to given radius in meters Radiuses array length should be same as coordinates array, eaach value separated by semi-colon. Input Value - {radius};{radius}[;{radius} ...] Radius has following format :- double &gt;&#x3D; 0 or unlimited (default) (optional)</param>
        /// <param name="steps">Returned route steps for each route leg [ true, false (default) ] (optional)</param>
        /// <param name="annotations">Returns additional metadata for each coordinate along the route geometry.  [ true, false (default), nodes, distance, duration, datasources, weight, speed ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="geometries">Returned route geometry format (influences overview and per step) [ polyline (default), polyline6, geojson ] (optional, default to &quot;&quot;polyline&quot;&quot;)</param>
        /// <param name="overview">Add overview geometry either full, simplified according to highest zoom level it could be display on, or not at all. [ simplified (default), full, false ] (optional, default to &quot;&quot;simplified&quot;&quot;)</param>
        /// <param name="timestamps">Timestamps for the input locations in seconds since UNIX epoch. Timestamps need to be monotonically increasing. [ {timestamp};{timestamp}[;{timestamp} ...]  integer seconds since UNIX epoch (optional)</param>
        /// <param name="gaps">Allows the input track splitting based on huge timestamp gaps between points. [ split (default), ignore ] (optional, default to &quot;&quot;split&quot;&quot;)</param>
        /// <param name="tidy">Allows the input track modification to obtain better matching quality for noisy tracks. [ true, false (default) ] (optional, default to &quot;&quot;false&quot;&quot;)</param>
        /// <param name="waypoints">Treats input coordinates indicated by given indices as waypoints in returned Match object. Default is to treat all input coordinates as waypoints. [ {index};{index};{index}... ] (optional)</param>
        /// <returns>Task of ApiResponse (DirectionsMatching)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DirectionsMatching>> MatchingAsyncWithHttpInfo (string coordinates, string generateHints = default(string), string approaches = default(string), string exclude = default(string), string bearings = default(string), string radiuses = default(string), string steps = default(string), string annotations = default(string), string geometries = default(string), string overview = default(string), string timestamps = default(string), string gaps = default(string), string tidy = default(string), string waypoints = default(string))
        {
            // verify the required parameter 'coordinates' is set
            if (coordinates == null)
                throw new ApiException(400, "Missing required parameter 'coordinates' when calling MatchingApi->Matching");

            var localVarPath = "/matching/driving/{coordinates}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (coordinates != null) localVarPathParams.Add("coordinates", this.Configuration.ApiClient.ParameterToString(coordinates)); // path parameter
            if (generateHints != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "generate_hints", generateHints)); // query parameter
            if (approaches != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "approaches", approaches)); // query parameter
            if (exclude != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "exclude", exclude)); // query parameter
            if (bearings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "bearings", bearings)); // query parameter
            if (radiuses != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "radiuses", radiuses)); // query parameter
            if (steps != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "steps", steps)); // query parameter
            if (annotations != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "annotations", annotations)); // query parameter
            if (geometries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "geometries", geometries)); // query parameter
            if (overview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "overview", overview)); // query parameter
            if (timestamps != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timestamps", timestamps)); // query parameter
            if (gaps != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gaps", gaps)); // query parameter
            if (tidy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tidy", tidy)); // query parameter
            if (waypoints != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "waypoints", waypoints)); // query parameter

            // authentication (key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", this.Configuration.GetApiKeyWithPrefix("key")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Matching", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DirectionsMatching>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DirectionsMatching) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DirectionsMatching)));
        }

    }
}
