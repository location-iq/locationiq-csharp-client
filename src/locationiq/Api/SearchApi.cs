/* 
 * LocationIQ
 *
 * LocationIQ provides flexible enterprise-grade location based solutions. We work with developers, startups and enterprises worldwide serving billions of requests everyday. This page provides an overview of the technical aspects of our API and will help you get started.
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using locationiq.Client;
using locationiq.Model;

namespace locationiq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISearchApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>List&lt;Location&gt;</returns>
        List<Location> Search (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int));

        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>ApiResponse of List&lt;Location&gt;</returns>
        ApiResponse<List<Location>> SearchWithHttpInfo (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>Task of List&lt;Location&gt;</returns>
        System.Threading.Tasks.Task<List<Location>> SearchAsync (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int));

        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Location&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Location>>> SearchAsyncWithHttpInfo (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SearchApi : ISearchApi
    {
        private locationiq.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SearchApi(String basePath)
        {
            this.Configuration = new locationiq.Client.Configuration { BasePath = basePath };

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class
        /// </summary>
        /// <returns></returns>
        public SearchApi()
        {
            this.Configuration = locationiq.Client.Configuration.Default;

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SearchApi(locationiq.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = locationiq.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public locationiq.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public locationiq.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>List&lt;Location&gt;</returns>
        public List<Location> Search (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int))
        {
             ApiResponse<List<Location>> localVarResponse = SearchWithHttpInfo(q, format, normalizecity, addressdetails, viewbox, bounded, limit, acceptLanguage, countrycodes, namedetails, dedupe, extratags, statecode, matchquality, postaladdress);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>ApiResponse of List&lt;Location&gt;</returns>
        public ApiResponse<List<Location>> SearchWithHttpInfo (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int))
        {
            // verify the required parameter 'q' is set
            if (q == null)
                throw new ApiException(400, "Missing required parameter 'q' when calling SearchApi->Search");
            // verify the required parameter 'format' is set
            if (format == null)
                throw new ApiException(400, "Missing required parameter 'format' when calling SearchApi->Search");
            // verify the required parameter 'normalizecity' is set
            if (normalizecity == null)
                throw new ApiException(400, "Missing required parameter 'normalizecity' when calling SearchApi->Search");

            var localVarPath = "/search.php";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (q != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (format != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "format", format)); // query parameter
            if (normalizecity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "normalizecity", normalizecity)); // query parameter
            if (addressdetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "addressdetails", addressdetails)); // query parameter
            if (viewbox != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "viewbox", viewbox)); // query parameter
            if (bounded != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "bounded", bounded)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (acceptLanguage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accept-language", acceptLanguage)); // query parameter
            if (countrycodes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "countrycodes", countrycodes)); // query parameter
            if (namedetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "namedetails", namedetails)); // query parameter
            if (dedupe != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "dedupe", dedupe)); // query parameter
            if (extratags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "extratags", extratags)); // query parameter
            if (statecode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "statecode", statecode)); // query parameter
            if (matchquality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "matchquality", matchquality)); // query parameter
            if (postaladdress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "postaladdress", postaladdress)); // query parameter

            // authentication (key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", this.Configuration.GetApiKeyWithPrefix("key")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Search", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Location>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<Location>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Location>)));
        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>Task of List&lt;Location&gt;</returns>
        public async System.Threading.Tasks.Task<List<Location>> SearchAsync (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int))
        {
             ApiResponse<List<Location>> localVarResponse = await SearchAsyncWithHttpInfo(q, format, normalizecity, addressdetails, viewbox, bounded, limit, acceptLanguage, countrycodes, namedetails, dedupe, extratags, statecode, matchquality, postaladdress);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <param name="statecode">Adds state or province code when available to the statecode key inside the address element. Currently supported for addresses in the USA, Canada and Australia. Defaults to 0 (optional)</param>
        /// <param name="matchquality">Returns additional information about quality of the result in a matchquality object. Read more Defaults to 0 [0,1] (optional)</param>
        /// <param name="postaladdress">Returns address inside the postaladdress key, that is specifically formatted for each country. Currently supported for addresses in Germany. Defaults to 0 [0,1] (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Location&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<Location>>> SearchAsyncWithHttpInfo (string q, string format, int normalizecity, int addressdetails = default(int), string viewbox = default(string), int bounded = default(int), int limit = default(int), string acceptLanguage = default(string), string countrycodes = default(string), int namedetails = default(int), int dedupe = default(int), int extratags = default(int), int statecode = default(int), int matchquality = default(int), int postaladdress = default(int))
        {
            // verify the required parameter 'q' is set
            if (q == null)
                throw new ApiException(400, "Missing required parameter 'q' when calling SearchApi->Search");
            // verify the required parameter 'format' is set
            if (format == null)
                throw new ApiException(400, "Missing required parameter 'format' when calling SearchApi->Search");
            // verify the required parameter 'normalizecity' is set
            if (normalizecity == null)
                throw new ApiException(400, "Missing required parameter 'normalizecity' when calling SearchApi->Search");

            var localVarPath = "/search.php";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (q != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (format != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "format", format)); // query parameter
            if (normalizecity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "normalizecity", normalizecity)); // query parameter
            if (addressdetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "addressdetails", addressdetails)); // query parameter
            if (viewbox != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "viewbox", viewbox)); // query parameter
            if (bounded != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "bounded", bounded)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (acceptLanguage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accept-language", acceptLanguage)); // query parameter
            if (countrycodes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "countrycodes", countrycodes)); // query parameter
            if (namedetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "namedetails", namedetails)); // query parameter
            if (dedupe != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "dedupe", dedupe)); // query parameter
            if (extratags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "extratags", extratags)); // query parameter
            if (statecode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "statecode", statecode)); // query parameter
            if (matchquality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "matchquality", matchquality)); // query parameter
            if (postaladdress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "postaladdress", postaladdress)); // query parameter

            // authentication (key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", this.Configuration.GetApiKeyWithPrefix("key")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Search", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Location>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<Location>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Location>)));
        }

    }
}
