/* 
 * LocationIQ
 *
 * LocationIQ provides flexible enterprise-grade location based solutions. We work with developers, startups and enterprises worldwide serving billions of requests everyday. This page provides an overview of the technical aspects of our API and will help you get started.
 *
 * OpenAPI spec version: 1.0.1
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using locationiq.Client;
using locationiq.Model;

namespace locationiq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISearchApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>List&lt;Location&gt;</returns>
        List<Location> Search (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null);

        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>ApiResponse of List&lt;Location&gt;</returns>
        ApiResponse<List<Location>> SearchWithHttpInfo (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>Task of List&lt;Location&gt;</returns>
        System.Threading.Tasks.Task<List<Location>> SearchAsync (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null);

        /// <summary>
        /// Forward Geocoding
        /// </summary>
        /// <remarks>
        /// The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </remarks>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Location&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Location>>> SearchAsyncWithHttpInfo (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SearchApi : ISearchApi
    {
        private locationiq.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SearchApi(String basePath)
        {
            this.Configuration = new locationiq.Client.Configuration { BasePath = basePath };

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SearchApi(locationiq.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = locationiq.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = locationiq.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public locationiq.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public locationiq.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>List&lt;Location&gt;</returns>
        public List<Location> Search (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null)
        {
             ApiResponse<List<Location>> localVarResponse = SearchWithHttpInfo(q, format, normalizecity, addressdetails, viewbox, bounded, limit, acceptLanguage, countrycodes, namedetails, dedupe, extratags);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>ApiResponse of List&lt;Location&gt;</returns>
        public ApiResponse< List<Location> > SearchWithHttpInfo (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null)
        {
            // verify the required parameter 'q' is set
            if (q == null)
                throw new ApiException(400, "Missing required parameter 'q' when calling SearchApi->Search");
            // verify the required parameter 'format' is set
            if (format == null)
                throw new ApiException(400, "Missing required parameter 'format' when calling SearchApi->Search");
            // verify the required parameter 'normalizecity' is set
            if (normalizecity == null)
                throw new ApiException(400, "Missing required parameter 'normalizecity' when calling SearchApi->Search");

            var localVarPath = "/search.php";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (q != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (format != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "format", format)); // query parameter
            if (normalizecity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "normalizecity", normalizecity)); // query parameter
            if (addressdetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "addressdetails", addressdetails)); // query parameter
            if (viewbox != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "viewbox", viewbox)); // query parameter
            if (bounded != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "bounded", bounded)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (acceptLanguage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accept-language", acceptLanguage)); // query parameter
            if (countrycodes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "countrycodes", countrycodes)); // query parameter
            if (namedetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "namedetails", namedetails)); // query parameter
            if (dedupe != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "dedupe", dedupe)); // query parameter
            if (extratags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "extratags", extratags)); // query parameter

            // authentication (key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", this.Configuration.GetApiKeyWithPrefix("key")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Search", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Location>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<Location>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Location>)));
        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>Task of List&lt;Location&gt;</returns>
        public async System.Threading.Tasks.Task<List<Location>> SearchAsync (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null)
        {
             ApiResponse<List<Location>> localVarResponse = await SearchAsyncWithHttpInfo(q, format, normalizecity, addressdetails, viewbox, bounded, limit, acceptLanguage, countrycodes, namedetails, dedupe, extratags);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Forward Geocoding The Search API allows converting addresses, such as a street address, into geographic coordinates (latitude and longitude). These coordinates can serve various use-cases, from placing markers on a map to helping algorithms determine nearby bus stops. This process is also known as Forward Geocoding.
        /// </summary>
        /// <exception cref="locationiq.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">Address to geocode</param>
        /// <param name="format">Format to geocode. Only JSON supported for SDKs</param>
        /// <param name="normalizecity">For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.</param>
        /// <param name="addressdetails">Include a breakdown of the address into elements. Defaults to 0. (optional)</param>
        /// <param name="viewbox">The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. (optional)</param>
        /// <param name="bounded">Restrict the results to only items contained with the viewbox (optional)</param>
        /// <param name="limit">Limit the number of returned results. Default is 10. (optional, default to 10)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)</param>
        /// <param name="countrycodes">Limit search to a list of countries. (optional)</param>
        /// <param name="namedetails">Include a list of alternative names in the results. These may include language variants, references, operator and brand. (optional)</param>
        /// <param name="dedupe">Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split in many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match; this is controlled by the dedupe parameter which defaults to 1. Since the limit is, for reasons of efficiency, enforced before and not after de-duplicating, it is possible that de-duplicating leaves you with less results than requested. (optional)</param>
        /// <param name="extratags">Include additional information in the result if available, e.g. wikipedia link, opening hours. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Location&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<Location>>> SearchAsyncWithHttpInfo (string q, string format, int? normalizecity, int? addressdetails = null, string viewbox = null, int? bounded = null, int? limit = null, string acceptLanguage = null, string countrycodes = null, int? namedetails = null, int? dedupe = null, int? extratags = null)
        {
            // verify the required parameter 'q' is set
            if (q == null)
                throw new ApiException(400, "Missing required parameter 'q' when calling SearchApi->Search");
            // verify the required parameter 'format' is set
            if (format == null)
                throw new ApiException(400, "Missing required parameter 'format' when calling SearchApi->Search");
            // verify the required parameter 'normalizecity' is set
            if (normalizecity == null)
                throw new ApiException(400, "Missing required parameter 'normalizecity' when calling SearchApi->Search");

            var localVarPath = "/search.php";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (q != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (format != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "format", format)); // query parameter
            if (normalizecity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "normalizecity", normalizecity)); // query parameter
            if (addressdetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "addressdetails", addressdetails)); // query parameter
            if (viewbox != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "viewbox", viewbox)); // query parameter
            if (bounded != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "bounded", bounded)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (acceptLanguage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accept-language", acceptLanguage)); // query parameter
            if (countrycodes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "countrycodes", countrycodes)); // query parameter
            if (namedetails != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "namedetails", namedetails)); // query parameter
            if (dedupe != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "dedupe", dedupe)); // query parameter
            if (extratags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "extratags", extratags)); // query parameter

            // authentication (key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", this.Configuration.GetApiKeyWithPrefix("key")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Search", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Location>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<Location>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Location>)));
        }

    }
}
